"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[112,367],{662:(e,t,i)=>{i.d(t,{A:()=>s});class s{async saveMap(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,t=e||this.mapData;if(!t)return console.error("No map data available to save"),!1;try{if("showSaveFilePicker"in window)return await this.saveMapWithFilePicker(t);return await this.saveMapWithPrompt(t)}catch(e){return console.error("Error saving map:",e),!1}}async saveMapWithFilePicker(e){try{let t=JSON.stringify(e,null,2),i=await window.showSaveFilePicker({suggestedName:this.mapFileName,types:[{description:"JSON Map Files",accept:{"application/json":[".json"]}}]}),s=await i.createWritable();return await s.write(t),await s.close(),!0}catch(e){if("AbortError"===e.name)return!1;throw e}}async saveMapWithPrompt(e){let t=JSON.stringify(e,null,2),i=prompt("Enter filename for your map:",this.mapFileName);if(!i)return!1;let s=i.endsWith(".json")?i:i+".json",r=new Blob([t],{type:"application/json"}),a=URL.createObjectURL(r),l=document.createElement("a");return l.href=a,l.download=s,document.body.appendChild(l),l.click(),document.body.removeChild(l),URL.revokeObjectURL(a),!0}async loadMap(e){return new Promise((t,i)=>{if(!e)return void i(Error("No file provided"));let s=new FileReader;s.onload=e=>{try{var s;let r=JSON.parse(null==(s=e.target)?void 0:s.result);this.validateMapData(r)?(this.mapData=r,t(r)):i(Error("Invalid map data format"))}catch(e){i(Error("Error parsing map file: "+e.message))}},s.onerror=()=>{i(Error("Error reading file"))},s.readAsText(e)})}async loadMapFromURL(e){try{let t="?t=".concat(Date.now()),i=await fetch(e+t,{cache:"no-cache",headers:{"Cache-Control":"no-cache, no-store, must-revalidate",Pragma:"no-cache",Expires:"0"}});if(!i.ok)throw Error("HTTP error! status: ".concat(i.status));let s=await i.json();if(this.validateMapData(s))return this.mapData=s,s;throw Error("Invalid map data format")}catch(e){throw console.error("Error loading map from URL:",e),e}}validateMapData(e){for(let t of["version","metadata","world","player","portal","enemies"])if(!e[t])return console.error("Missing required field: ".concat(t)),!1;if(!e.player.startPosition||"number"!=typeof e.player.startPosition.x||"number"!=typeof e.player.startPosition.y)return console.error("Invalid player start position"),!1;if(!e.portal.position||"number"!=typeof e.portal.position.x||"number"!=typeof e.portal.position.y)return console.error("Invalid portal position"),!1;if(!Array.isArray(e.enemies))return console.error("Enemies must be an array"),!1;for(let t of e.enemies)if(!t.id||!t.type||!t.position||!t.enemyType)return console.error("Invalid enemy data:",t),!1;return!0}getMapData(){return this.mapData}setMapData(e){return!!this.validateMapData(e)&&(this.mapData=e,!0)}createMapFromGameState(){let e=this.scene;if(!e.player||!e.portalSprite||!e.enemies)return console.error("Cannot create map: missing game objects"),null;let t={version:"1.0",metadata:{name:"Generated Map",description:"Map generated from current game state",created:new Date().toISOString(),author:"Game System"},world:{width:4100,height:800,tileSize:32},player:{startPosition:{x:0,y:0},character:"A"},portal:{position:{x:0,y:0},size:{width:100,height:100}},enemies:[],platforms:[],collectibles:[],checkpoints:[],tiles:[]};return t.player.startPosition.x=e.player.x,t.player.startPosition.y=e.player.y,t.player.character=e.player.characterKey,t.portal.position.x=e.portalSprite.x,t.portal.position.y=e.portalSprite.y,t.enemies=[],e.enemies.forEach((e,i)=>{t.enemies.push({id:"enemy_".concat(i+1),type:e.type,enemyType:e.enemyType,position:{x:e.x,y:e.y},properties:{damage:e.damage,health:e.health,speed:e.speed,patrolRange:e.patrolRange||150}})}),t}exportMapData(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,t=e||this.mapData;return t?JSON.stringify(t,null,2):(console.error("No map data available to export"),null)}importMapData(e){try{let t=JSON.parse(e);if(this.validateMapData(t))return this.mapData=t,!0;return!1}catch(e){return console.error("Error importing map data:",e),!1}}constructor(e){this.scene=e,this.mapData=null,this.mapFileName="default.json"}}},1367:(e,t,i)=>{i.d(t,{GAME_CONFIG:()=>s,o:()=>r});let s={width:1200,height:800,backgroundColor:"#0a0a2e",physics:{default:"arcade",arcade:{gravity:{y:300},debug:!1}},scale:{mode:"FIT",autoCenter:"CENTER_BOTH"},render:{antialias:!0}},r={characters:"/assets/images/characters",enemies:"/assets/images/enemies",backgrounds:"/assets/images/backgrounds",ui:"/assets/images/ui",tiles:"/assets/images/tiles",audio:{music:"/assets/audio/music",sfx:"/assets/audio/sfx"},maps:"/assets/maps"}},2042:(e,t,i)=>{i.d(t,{W:()=>s});class s{initializeTilemap(){this.tiles=[];for(let e=0;e<this.mapHeight;e++){this.tiles[e]=[];for(let t=0;t<this.mapWidth;t++)this.tiles[e][t]=0}this.visualLayer=this.scene.add.graphics(),this.visualLayer.setDepth(4),this.visualLayer.setVisible(!0),this.collisionBodies=[],this.tileSpriteIndices=[],this.tileSprites=[]}setTile(e,t,i){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;e>=0&&e<this.mapWidth&&t>=0&&t<this.mapHeight&&(this.tiles[t][e]=i,i===s.TILE_TYPES.SOLID&&null!==r&&(this.tileSpriteIndices||(this.tileSpriteIndices=[]),this.tileSpriteIndices[t]=this.tileSpriteIndices[t]||[],this.tileSpriteIndices[t][e]=r),this.updateTileVisual(e,t))}getTile(e,t){return e>=0&&e<this.mapWidth&&t>=0&&t<this.mapHeight?this.tiles[t][e]:s.TILE_TYPES.EMPTY}getTileSpriteIndex(e,t){return e>=0&&e<this.mapWidth&&t>=0&&t<this.mapHeight&&this.tileSpriteIndices&&this.tileSpriteIndices[t]&&void 0!==this.tileSpriteIndices[t][e]?this.tileSpriteIndices[t][e]:null}worldToTile(e,t){return{x:Math.floor(e/this.tileSize),y:Math.floor(t/this.tileSize)}}tileToWorld(e,t){return{x:e*this.tileSize,y:t*this.tileSize}}updateTileVisual(e,t){let i=this.tiles[t][e],r=this.tileToWorld(e,t);if(this.clearTileVisual(e,t),i!==s.TILE_TYPES.EMPTY){let a=null;this.tileSpriteIndices&&this.tileSpriteIndices[t]&&void 0!==this.tileSpriteIndices[t][e]&&(a=this.tileSpriteIndices[t][e]);let l="ground";l=t>=this.mapHeight-3?"ground":this.getTile(e,t+1)===s.TILE_TYPES.EMPTY?"platform":"wall",this.drawTileVisual(r.x,r.y,i,l,a)}}clearTileVisual(e,t){if(this.tileSprites){let i=this.tileToWorld(e,t),s=i.x+this.tileSize/2,r=i.y+this.tileSize/2;for(let e=this.tileSprites.length-1;e>=0;e--){let t=this.tileSprites[e];t&&t.x===s&&t.y===r&&(t.destroy(),this.tileSprites.splice(e,1))}}}drawTileVisual(e,t,i){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;if(i===s.TILE_TYPES.EMPTY)return;if(!this.scene.textures.exists("tileset_sprites"))return void console.warn("Tileset textures not ready yet, skipping tile visual");let l=0;(i===s.TILE_TYPES.SOLID||i>0)&&(l=null!==a?a:"ground"===r?s.TILE_IMAGES[s.TILE_TYPES.SOLID].GROUND:"wall"===r?s.TILE_IMAGES[s.TILE_TYPES.SOLID].WALL:"platform"===r?s.TILE_IMAGES[s.TILE_TYPES.SOLID].PLATFORM:s.TILE_IMAGES[s.TILE_TYPES.SOLID].GROUND);let o=this.scene.add.image(e+this.tileSize/2,t+this.tileSize/2,"tileset_sprites",l);o.setDisplaySize(this.tileSize,this.tileSize),o.setDepth(4),this.tileSprites||(this.tileSprites=[]),this.tileSprites.push(o)}redrawVisualLayer(){this.tileSprites&&(this.tileSprites.forEach(e=>e.destroy()),this.tileSprites=[]),this.visualLayer.clear();for(let e=0;e<this.mapHeight;e++)for(let t=0;t<this.mapWidth;t++){let i=this.tiles[e][t];if(i!==s.TILE_TYPES.EMPTY){let r=this.tileToWorld(t,e),a=null;this.tileSpriteIndices&&this.tileSpriteIndices[e]&&void 0!==this.tileSpriteIndices[e][t]&&(a=this.tileSpriteIndices[e][t]);let l="ground";l=e>=this.mapHeight-3?"ground":this.getTile(t,e+1)===s.TILE_TYPES.EMPTY?"platform":"wall",this.drawTileVisual(r.x,r.y,i,l,a)}}}redrawTilesAfterTexturesReady(){this.scene.textures.exists("tileset_sprites")?this.redrawVisualLayer():this.scene.time.delayedCall(100,()=>{this.redrawTilesAfterTexturesReady()})}createCollisionBodies(){this.collisionBodies=[],this.collisionGroup=this.scene.physics.add.staticGroup();for(let e=0;e<this.mapHeight;e++)for(let t=0;t<this.mapWidth;t++){let i=this.tiles[e][t];if(this.isSolidTile(i)){let s=this.tileToWorld(t,e),r=this.createTileCollisionBody(s.x,s.y,i);this.collisionBodies.push(r),this.collisionGroup.add(r)}}return this.collisionGroup}isSolidTile(e){return e!==s.TILE_TYPES.EMPTY}createTileCollisionBody(e,t,i){let s=this.scene.add.rectangle(e+this.tileSize/2,t+this.tileSize/2,this.tileSize,this.tileSize);return this.scene.physics.add.existing(s),s.body.setImmovable(!0),s.body.setAllowGravity(!1),s.setVisible(!1),s}checkCollision(e,t){let i=this.worldToTile(e,t),s=this.getTile(i.x,i.y);return this.isSolidTile(s)}findEnemySpawnPosition(){let e=!(arguments.length>0)||void 0===arguments[0]||arguments[0];if(e){let e=this.mapHeight-3,t=Math.floor(Math.random()*this.mapWidth),i=this.tileToWorld(t,e);return{x:i.x+this.tileSize/2,y:i.y-16}}{let e=[];for(let t=0;t<this.mapHeight-3;t++)for(let i=0;i<this.mapWidth;i++)this.tiles[t][i]===s.TILE_TYPES.SOLID&&e.push({x:i,y:t});if(e.length>0){let t=e[Math.floor(Math.random()*e.length)],i=this.tileToWorld(t.x,t.y);return{x:i.x+this.tileSize/2,y:i.y-16}}}return this.findEnemySpawnPosition(!0)}constructor(e){this.scene=e,this.tileSize=32,this.mapWidth=129,this.mapHeight=25,this.tiles=[],this.collisionLayer=null,this.visualLayer=null,this.initializeTilemap()}}s.TILE_TYPES={EMPTY:0,SOLID:1},s.TILE_IMAGES={[s.TILE_TYPES.SOLID]:{GROUND:0,WALL:1,PLATFORM:2}}}}]);